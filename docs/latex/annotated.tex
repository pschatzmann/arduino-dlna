\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1Allocator}{tiny\+\_\+dlna\+::\+Allocator}} \\*Memory allocateator which uses malloc }{\pageref{classtiny__dlna_1_1Allocator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1AllocatorExt}{tiny\+\_\+dlna\+::\+Allocator\+Ext}} \\*Memory allocateator which uses ps\+\_\+malloc (on the ESP32) and if this fails it resorts to malloc }{\pageref{classtiny__dlna_1_1AllocatorExt}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1DLNADevice}{tiny\+\_\+dlna\+::\+DLNADevice}} \\*Setup of a Basic DLNA Device service. The device registers itself to the network and answers to the DLNA queries and requests. A DLNA device uses UDP, Http, XML and Soap to discover and manage a service, so there is quite some complexity involved\+: }{\pageref{classtiny__dlna_1_1DLNADevice}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1DLNADeviceInfo}{tiny\+\_\+dlna\+::\+DLNADevice\+Info}} \\*Device Attributes and generation of XML using urn\+:schemas-\/upnp-\/org\+:device-\/1-\/0. We could just reutrn a predefined device xml document, but we provide a dynamic generation of the service xml which should be more memory efficient }{\pageref{classtiny__dlna_1_1DLNADeviceInfo}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1DLNARequestParser}{tiny\+\_\+dlna\+::\+DLNARequest\+Parser}} \\*Translates DLNA UDP Requests to \mbox{\hyperlink{structtiny__dlna_1_1Schedule}{Schedule}} so that we can schedule a reply }{\pageref{classtiny__dlna_1_1DLNARequestParser}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1DLNAServiceInfo}{tiny\+\_\+dlna\+::\+DLNAService\+Info}} \\*Attributes needed for the DLNA Service Definition }{\pageref{classtiny__dlna_1_1DLNAServiceInfo}}{}
\item\contentsline{section}{\mbox{\hyperlink{structtiny__dlna_1_1IPAddressAndPort}{tiny\+\_\+dlna\+::\+IPAddress\+And\+Port}} \\*IP Adress including Port information }{\pageref{structtiny__dlna_1_1IPAddressAndPort}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1List_1_1Iterator}{tiny\+\_\+dlna\+::\+List$<$ T $>$\+::\+Iterator}} }{\pageref{classtiny__dlna_1_1List_1_1Iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1Vector_1_1iterator}{tiny\+\_\+dlna\+::\+Vector$<$ T $>$\+::iterator}} \\*Iterator for the \mbox{\hyperlink{classtiny__dlna_1_1Vector}{Vector}} class }{\pageref{classtiny__dlna_1_1Vector_1_1iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1IUDPService}{tiny\+\_\+dlna\+::\+IUDPService}} }{\pageref{classtiny__dlna_1_1IUDPService}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1List}{tiny\+\_\+dlna\+::\+List$<$ T $>$}} \\*Double linked list }{\pageref{classtiny__dlna_1_1List}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1LoggerClass}{tiny\+\_\+dlna\+::\+Logger\+Class}} \\*Logger that writes messages dependent on the log level }{\pageref{classtiny__dlna_1_1LoggerClass}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1MSearchReplySchedule}{tiny\+\_\+dlna\+::\+MSearch\+Reply\+Schedule}} \\*Answer to MSearch request }{\pageref{classtiny__dlna_1_1MSearchReplySchedule}}{}
\item\contentsline{section}{\mbox{\hyperlink{structtiny__dlna_1_1List_1_1Node}{tiny\+\_\+dlna\+::\+List$<$ T $>$\+::\+Node}} }{\pageref{structtiny__dlna_1_1List_1_1Node}}{}
\item\contentsline{section}{\mbox{\hyperlink{structtiny__dlna_1_1QueueLockFree_1_1Node}{tiny\+\_\+dlna\+::\+Queue\+Lock\+Free$<$ T $>$\+::\+Node}} }{\pageref{structtiny__dlna_1_1QueueLockFree_1_1Node}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1PostAliveSchedule}{tiny\+\_\+dlna\+::\+Post\+Alive\+Schedule}} \\*Send out Post\+Alive messages\+: Repeated every 5 seconds }{\pageref{classtiny__dlna_1_1PostAliveSchedule}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1PostByeSchedule}{tiny\+\_\+dlna\+::\+Post\+Bye\+Schedule}} \\*Send out Bye\+Bye message }{\pageref{classtiny__dlna_1_1PostByeSchedule}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1QueueLockFree}{tiny\+\_\+dlna\+::\+Queue\+Lock\+Free$<$ T $>$}} \\*A simple single producer, single consumer lock free queue }{\pageref{classtiny__dlna_1_1QueueLockFree}}{}
\item\contentsline{section}{\mbox{\hyperlink{structtiny__dlna_1_1RequestData}{tiny\+\_\+dlna\+::\+Request\+Data}} \\*Provides information of the received UDP which consists of the (xml) data and the peer address and port }{\pageref{structtiny__dlna_1_1RequestData}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1RingBuffer}{tiny\+\_\+dlna\+::\+Ring\+Buffer}} \\*Implementation of a Simple Circular Buffer. Instead of comparing the position of the read and write pointer in order to figure out if we still have characters available or space left to write we keep track of the actual length which is easier to follow }{\pageref{classtiny__dlna_1_1RingBuffer}}{}
\item\contentsline{section}{\mbox{\hyperlink{structtiny__dlna_1_1Schedule}{tiny\+\_\+dlna\+::\+Schedule}} \\*An individual \mbox{\hyperlink{structtiny__dlna_1_1Schedule}{Schedule}} (to send out UDP messages) }{\pageref{structtiny__dlna_1_1Schedule}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1Scheduler}{tiny\+\_\+dlna\+::\+Scheduler}} \\*\mbox{\hyperlink{classtiny__dlna_1_1Scheduler}{Scheduler}} which processes all due Schedules (to send out UDP replies) }{\pageref{classtiny__dlna_1_1Scheduler}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1Str}{tiny\+\_\+dlna\+::\+Str}} \\*String implementation which keeps the data on the heap. We grow the allocated memory only if the copy source is not fitting }{\pageref{classtiny__dlna_1_1Str}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1StrView}{tiny\+\_\+dlna\+::\+Str\+View}} \\*A simple wrapper to provide string functions on char$\ast$. If the underlying char$\ast$ is a const we do not allow any updates; The ownership of the chr$\ast$ must be managed externally! }{\pageref{classtiny__dlna_1_1StrView}}{}
\item\contentsline{section}{\mbox{\hyperlink{classtiny__dlna_1_1Vector}{tiny\+\_\+dlna\+::\+Vector$<$ T $>$}} \\*\mbox{\hyperlink{classtiny__dlna_1_1Vector}{Vector}} implementation which provides the most important methods as defined by std\+::vector. This class it is quite handy to have and most of the times quite better then dealing with raw c arrays }{\pageref{classtiny__dlna_1_1Vector}}{}
\item\contentsline{section}{\mbox{\hyperlink{structtiny__dlna_1_1XMLPrinter}{tiny\+\_\+dlna\+::\+XMLPrinter}} \\*Functions to efficiently output XML. XML data contains a lot of redundancy so it is more memory efficient to generate the data instead of using a predefined XML document }{\pageref{structtiny__dlna_1_1XMLPrinter}}{}
\end{DoxyCompactList}
